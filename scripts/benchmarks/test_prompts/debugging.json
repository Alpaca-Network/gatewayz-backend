{
  "category": "debugging",
  "description": "Bug identification and fixing tasks",
  "test_cases": [
    {
      "id": "db_001",
      "difficulty": "easy",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef find_max(numbers):\n    max_val = 0\n    for num in numbers:\n        if num > max_val:\n            max_val = num\n    return max_val\n\n# Test: find_max([-5, -2, -10]) should return -2\n```",
      "expected_behavior": "Should identify that initializing to 0 fails for all-negative lists, fix by using first element or float('-inf')",
      "evaluation_criteria": ["bug_identified", "correct_fix", "explanation_quality"],
      "tags": ["initialization", "edge_case", "easy"]
    },
    {
      "id": "db_002",
      "difficulty": "easy",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef reverse_string(s):\n    reversed = ''\n    for i in range(len(s), 0):\n        reversed += s[i]\n    return reversed\n```",
      "expected_behavior": "Should identify range issue: needs range(len(s)-1, -1, -1) or simply s[::-1]",
      "evaluation_criteria": ["bug_identified", "correct_fix", "explanation_quality"],
      "tags": ["range", "off_by_one", "easy"]
    },
    {
      "id": "db_003",
      "difficulty": "easy",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef count_occurrences(text, char):\n    count = 0\n    for c in text:\n        if c == char:\n            count += 1\n        return count\n```",
      "expected_behavior": "Should identify indentation error - return is inside the loop",
      "evaluation_criteria": ["bug_identified", "correct_fix", "explanation_quality"],
      "tags": ["indentation", "loop", "easy"]
    },
    {
      "id": "db_004",
      "difficulty": "easy",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef remove_duplicates(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item in seen:\n            result.append(item)\n        seen.add(item)\n    return result\n```",
      "expected_behavior": "Should identify logic is inverted - should be 'not in seen'",
      "evaluation_criteria": ["bug_identified", "correct_fix", "explanation_quality"],
      "tags": ["logic_error", "set", "easy"]
    },
    {
      "id": "db_005",
      "difficulty": "easy",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef calculate_average(numbers):\n    total = sum(numbers)\n    average = total / len(numbers)\n    return average\n\n# Crashes on calculate_average([])\n```",
      "expected_behavior": "Should identify division by zero for empty list, add guard clause",
      "evaluation_criteria": ["bug_identified", "correct_fix", "explanation_quality"],
      "tags": ["division_by_zero", "edge_case", "easy"]
    },
    {
      "id": "db_006",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid\n        else:\n            right = mid\n    return -1\n\n# Goes into infinite loop sometimes\n```",
      "expected_behavior": "Should identify left = mid causes infinite loop, needs left = mid + 1",
      "evaluation_criteria": ["bug_identified", "correct_fix", "infinite_loop_explained"],
      "tags": ["binary_search", "infinite_loop", "medium"]
    },
    {
      "id": "db_007",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef merge_dicts(dict1, dict2):\n    result = dict1\n    for key, value in dict2.items():\n        result[key] = value\n    return result\n\nd1 = {'a': 1, 'b': 2}\nd2 = {'c': 3}\nmerged = merge_dicts(d1, d2)\n# Problem: d1 is also modified!\n```",
      "expected_behavior": "Should identify reference aliasing issue, need to copy dict1 first",
      "evaluation_criteria": ["bug_identified", "correct_fix", "mutation_explained"],
      "tags": ["reference", "mutation", "medium"]
    },
    {
      "id": "db_008",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef flatten(nested_list):\n    result = []\n    for item in nested_list:\n        if type(item) == list:\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n\n# Works but fails on: flatten([[1, 2], (3, 4)])\n```",
      "expected_behavior": "Should identify type check is too strict, should use isinstance with Iterable or check for str explicitly",
      "evaluation_criteria": ["bug_identified", "correct_fix", "type_checking_explained"],
      "tags": ["type_checking", "recursion", "medium"]
    },
    {
      "id": "db_009",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\nclass Counter:\n    count = 0\n    \n    def __init__(self):\n        Counter.count += 1\n    \n    def get_count(self):\n        return self.count\n\nc1 = Counter()\nc2 = Counter()\nprint(c1.get_count())  # Expected: 1, Got: 2\n```",
      "expected_behavior": "Should identify class variable vs instance variable issue",
      "evaluation_criteria": ["bug_identified", "correct_fix", "class_vs_instance_explained"],
      "tags": ["oop", "class_variable", "medium"]
    },
    {
      "id": "db_010",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef memoize(func):\n    cache = {}\n    def wrapper(n):\n        if n not in cache:\n            cache[n] = func(n)\n        return cache[n]\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Problem: fibonacci(35) is still slow\n```",
      "expected_behavior": "Should identify that recursive calls inside fibonacci don't use the wrapper. Need to update func to use wrapper or the global name",
      "evaluation_criteria": ["bug_identified", "correct_fix", "decorator_behavior_explained"],
      "tags": ["decorator", "memoization", "medium"]
    },
    {
      "id": "db_011",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\nimport threading\n\nclass BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n    \n    def withdraw(self, amount):\n        if self.balance >= amount:\n            self.balance -= amount\n            return True\n        return False\n\n# Race condition when multiple threads call withdraw\n```",
      "expected_behavior": "Should identify race condition between check and update, add threading.Lock",
      "evaluation_criteria": ["bug_identified", "correct_fix", "race_condition_explained"],
      "tags": ["threading", "race_condition", "medium"]
    },
    {
      "id": "db_012",
      "difficulty": "medium",
      "prompt": "Find and fix the bug in this code:\n\n```python\ndef parse_json_safely(json_string):\n    import json\n    try:\n        data = json.loads(json_string)\n        return data['key']\n    except json.JSONDecodeError:\n        return None\n\n# Crashes on: parse_json_safely('{}')\n```",
      "expected_behavior": "Should identify KeyError not being caught when 'key' doesn't exist",
      "evaluation_criteria": ["bug_identified", "correct_fix", "exception_handling_explained"],
      "tags": ["exception_handling", "json", "medium"]
    },
    {
      "id": "db_013",
      "difficulty": "hard",
      "prompt": "Find and fix the bug in this code:\n\n```python\nfrom functools import lru_cache\n\nclass Graph:\n    def __init__(self, edges):\n        self.adj = {}\n        for u, v in edges:\n            self.adj.setdefault(u, []).append(v)\n    \n    @lru_cache(maxsize=None)\n    def has_path(self, start, end, visited=frozenset()):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited = visited | {start}\n        for neighbor in self.adj.get(start, []):\n            if self.has_path(neighbor, end, visited):\n                return True\n        return False\n\n# lru_cache doesn't work correctly here\n```",
      "expected_behavior": "Should identify that self is not hashable, lru_cache on instance method is problematic. Multiple issues to address.",
      "evaluation_criteria": ["multiple_bugs_identified", "correct_fix", "caching_with_self_explained"],
      "tags": ["caching", "oop", "hard"]
    },
    {
      "id": "db_014",
      "difficulty": "hard",
      "prompt": "Find and fix the bug in this code:\n\n```python\nasync def fetch_all(urls):\n    import aiohttp\n    import asyncio\n    \n    async with aiohttp.ClientSession() as session:\n        tasks = []\n        for url in urls:\n            task = session.get(url)\n            tasks.append(task)\n        \n        responses = await asyncio.gather(*tasks)\n        results = []\n        for resp in responses:\n            results.append(await resp.text())\n        return results\n\n# Sessions are not being properly awaited/closed\n```",
      "expected_behavior": "Should identify that session.get returns a context manager that needs to be awaited within async with",
      "evaluation_criteria": ["bug_identified", "correct_async_pattern", "resource_management_explained"],
      "tags": ["async", "aiohttp", "hard"]
    },
    {
      "id": "db_015",
      "difficulty": "hard",
      "prompt": "Find and fix the memory leak in this code:\n\n```python\nclass EventEmitter:\n    def __init__(self):\n        self.listeners = {}\n    \n    def on(self, event, callback):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        self.listeners[event].append(callback)\n    \n    def emit(self, event, *args):\n        for callback in self.listeners.get(event, []):\n            callback(*args)\n\nclass Widget:\n    def __init__(self, emitter):\n        self.emitter = emitter\n        emitter.on('update', self.handle_update)\n    \n    def handle_update(self, data):\n        print(f'Widget received: {data}')\n\n# Widgets are never garbage collected even after going out of scope\n```",
      "expected_behavior": "Should identify that emitter holds reference to widget via callback, need weak references or explicit cleanup",
      "evaluation_criteria": ["memory_leak_identified", "correct_fix", "reference_cycle_explained"],
      "tags": ["memory_leak", "weak_reference", "hard"]
    }
  ]
}
