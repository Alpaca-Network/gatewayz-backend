


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."activity_log" (
    "id" bigint NOT NULL,
    "user_id" integer NOT NULL,
    "timestamp" timestamp with time zone DEFAULT "now"() NOT NULL,
    "model" character varying(255) NOT NULL,
    "provider" character varying(100) NOT NULL,
    "tokens" integer DEFAULT 0 NOT NULL,
    "cost" numeric(10,4) DEFAULT 0 NOT NULL,
    "speed" numeric(10,2) DEFAULT 0,
    "finish_reason" character varying(50) DEFAULT 'stop'::character varying,
    "app" character varying(100) DEFAULT 'API'::character varying,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."activity_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."activity_log" IS 'Tracks all API activity for users including model calls, tokens, cost, and performance metrics';



ALTER TABLE "public"."activity_log" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."activity_log_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."api_keys_new" (
    "id" bigint NOT NULL,
    "user_id" bigint NOT NULL,
    "api_key" character varying(255) NOT NULL,
    "key_hash" character varying(255),
    "key_name" character varying(255) NOT NULL,
    "environment_tag" character varying(50) DEFAULT 'live'::character varying,
    "is_primary" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "scope_permissions" "jsonb" DEFAULT '{}'::"jsonb",
    "ip_allowlist" "text"[] DEFAULT ARRAY[]::"text"[],
    "domain_referrers" "text"[] DEFAULT ARRAY[]::"text"[],
    "expiration_date" timestamp with time zone,
    "max_requests" integer,
    "requests_used" integer DEFAULT 0,
    "last_used_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "encrypted_key" "text"
);


ALTER TABLE "public"."api_keys_new" OWNER TO "postgres";


COMMENT ON TABLE "public"."api_keys_new" IS 'API keys for user authentication with advanced security features';



CREATE SEQUENCE IF NOT EXISTS "public"."api_keys_new_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."api_keys_new_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."api_keys_new_id_seq" OWNED BY "public"."api_keys_new"."id";



CREATE TABLE IF NOT EXISTS "public"."chat_messages" (
    "id" integer NOT NULL,
    "session_id" integer NOT NULL,
    "role" character varying(20) NOT NULL,
    "content" "text" NOT NULL,
    "model" character varying(100),
    "tokens" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "chat_messages_role_check" CHECK ((("role")::"text" = ANY ((ARRAY['user'::character varying, 'assistant'::character varying])::"text"[])))
);


ALTER TABLE "public"."chat_messages" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_messages" IS 'Stores individual messages within chat sessions';



COMMENT ON COLUMN "public"."chat_messages"."session_id" IS 'Reference to the chat session this message belongs to';



COMMENT ON COLUMN "public"."chat_messages"."role" IS 'Message role: user or assistant';



COMMENT ON COLUMN "public"."chat_messages"."content" IS 'The actual message content';



COMMENT ON COLUMN "public"."chat_messages"."tokens" IS 'Number of tokens in this message';



CREATE SEQUENCE IF NOT EXISTS "public"."chat_messages_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."chat_messages_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."chat_messages_id_seq" OWNED BY "public"."chat_messages"."id";



CREATE TABLE IF NOT EXISTS "public"."chat_sessions" (
    "id" integer NOT NULL,
    "user_id" integer NOT NULL,
    "title" character varying(255) NOT NULL,
    "model" character varying(100) DEFAULT 'openai/gpt-3.5-turbo'::character varying NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."chat_sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_sessions" IS 'Stores chat sessions for users';



COMMENT ON COLUMN "public"."chat_sessions"."user_id" IS 'Reference to the user who owns this session';



COMMENT ON COLUMN "public"."chat_sessions"."title" IS 'Display title for the chat session';



COMMENT ON COLUMN "public"."chat_sessions"."model" IS 'AI model used for this session';



COMMENT ON COLUMN "public"."chat_sessions"."is_active" IS 'Soft delete flag - FALSE means session is deleted';



CREATE SEQUENCE IF NOT EXISTS "public"."chat_sessions_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."chat_sessions_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."chat_sessions_id_seq" OWNED BY "public"."chat_sessions"."id";



CREATE TABLE IF NOT EXISTS "public"."credit_transactions" (
    "id" bigint NOT NULL,
    "user_id" integer NOT NULL,
    "amount" numeric(10,2) NOT NULL,
    "transaction_type" character varying(50) NOT NULL,
    "description" "text",
    "payment_id" integer,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "balance_before" numeric(10,2) NOT NULL,
    "balance_after" numeric(10,2) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" character varying(100)
);


ALTER TABLE "public"."credit_transactions" OWNER TO "postgres";


ALTER TABLE "public"."credit_transactions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."credit_transactions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."openrouter_apps" (
    "id" integer NOT NULL,
    "rank" integer NOT NULL,
    "app_name" "text" NOT NULL,
    "description" "text",
    "tokens" "text",
    "is_new" boolean DEFAULT false,
    "app_url" "text",
    "domain" "text",
    "image_url" "text",
    "time_period" "text" NOT NULL,
    "scraped_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."openrouter_apps" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."latest_apps" WITH ("security_invoker"='on') AS
 SELECT DISTINCT ON ("time_period", "rank") "id",
    "rank",
    "app_name",
    "description",
    "tokens",
    "is_new",
    "app_url",
    "domain",
    "image_url",
    "time_period",
    "scraped_at"
   FROM "public"."openrouter_apps"
  ORDER BY "time_period", "rank", "scraped_at" DESC;


ALTER VIEW "public"."latest_apps" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."openrouter_models" (
    "id" integer NOT NULL,
    "rank" integer NOT NULL,
    "model_name" "text" NOT NULL,
    "author" "text" NOT NULL,
    "tokens" "text",
    "trend_percentage" "text",
    "trend_direction" "text",
    "trend_icon" "text",
    "trend_color" "text",
    "model_url" "text",
    "author_url" "text",
    "time_period" "text" NOT NULL,
    "scraped_at" timestamp with time zone DEFAULT "now"(),
    "logo_url" "text"
);


ALTER TABLE "public"."openrouter_models" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."latest_models" WITH ("security_invoker"='on') AS
 SELECT DISTINCT ON ("time_period", "rank") "id",
    "rank",
    "model_name",
    "author",
    "tokens",
    "trend_percentage",
    "trend_direction",
    "trend_icon",
    "trend_color",
    "model_url",
    "author_url",
    "time_period",
    "scraped_at"
   FROM "public"."openrouter_models"
  ORDER BY "time_period", "rank", "scraped_at" DESC;


ALTER VIEW "public"."latest_models" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."openrouter_apps_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."openrouter_apps_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."openrouter_apps_id_seq" OWNED BY "public"."openrouter_apps"."id";



CREATE SEQUENCE IF NOT EXISTS "public"."openrouter_models_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."openrouter_models_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."openrouter_models_id_seq" OWNED BY "public"."openrouter_models"."id";



CREATE TABLE IF NOT EXISTS "public"."payments" (
    "id" bigint NOT NULL,
    "user_id" bigint NOT NULL,
    "amount_usd" numeric(10,2) NOT NULL,
    "amount_cents" integer NOT NULL,
    "credits_purchased" integer DEFAULT 0 NOT NULL,
    "bonus_credits" integer DEFAULT 0 NOT NULL,
    "currency" character varying(3) DEFAULT 'usd'::character varying NOT NULL,
    "payment_method" character varying(50) DEFAULT 'stripe'::character varying NOT NULL,
    "status" character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    "stripe_payment_intent_id" character varying(255),
    "stripe_checkout_session_id" character varying(255),
    "stripe_customer_id" character varying(255),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "failed_at" timestamp with time zone,
    CONSTRAINT "payments_amount_cents_check" CHECK (("amount_cents" >= 0)),
    CONSTRAINT "payments_amount_usd_check" CHECK (("amount_usd" >= (0)::numeric)),
    CONSTRAINT "payments_bonus_credits_check" CHECK (("bonus_credits" >= 0)),
    CONSTRAINT "payments_credits_purchased_check" CHECK (("credits_purchased" >= 0))
);


ALTER TABLE "public"."payments" OWNER TO "postgres";


COMMENT ON TABLE "public"."payments" IS 'Payment records for Stripe transactions and credit purchases';



CREATE SEQUENCE IF NOT EXISTS "public"."payments_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."payments_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."payments_id_seq" OWNED BY "public"."payments"."id";



CREATE TABLE IF NOT EXISTS "public"."plans" (
    "id" bigint NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "price_per_month" numeric(10,2) DEFAULT 0,
    "daily_request_limit" integer DEFAULT 1000,
    "daily_token_limit" integer DEFAULT 100000,
    "monthly_request_limit" integer DEFAULT 30000,
    "monthly_token_limit" integer DEFAULT 3000000,
    "features" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "max_concurrent_requests" integer DEFAULT 5
);


ALTER TABLE "public"."plans" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."plans_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."plans_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."plans_id_seq" OWNED BY "public"."plans"."id";



CREATE TABLE IF NOT EXISTS "public"."pricing_tiers" (
    "id" integer NOT NULL,
    "tier_name" character varying(50) NOT NULL,
    "price_per_token" numeric(10,6) DEFAULT 0.000020 NOT NULL,
    "price_per_1k_tokens" numeric(10,4) DEFAULT 0.0200 NOT NULL,
    "price_per_1m_tokens" numeric(10,2) DEFAULT 20.00 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."pricing_tiers" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."pricing_tiers_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."pricing_tiers_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."pricing_tiers_id_seq" OWNED BY "public"."pricing_tiers"."id";



CREATE TABLE IF NOT EXISTS "public"."trial_config" (
    "id" integer NOT NULL,
    "trial_days" integer DEFAULT 3 NOT NULL,
    "trial_credits" numeric(10,2) DEFAULT 10.00 NOT NULL,
    "trial_tokens" integer DEFAULT 500000 NOT NULL,
    "trial_requests" integer DEFAULT 1000 NOT NULL,
    "trial_max_concurrent_requests" integer DEFAULT 5 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."trial_config" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."trial_config_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."trial_config_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."trial_config_id_seq" OWNED BY "public"."trial_config"."id";



CREATE TABLE IF NOT EXISTS "public"."usage_records" (
    "id" bigint NOT NULL,
    "user_id" integer NOT NULL,
    "api_key" "text" NOT NULL,
    "model" "text" NOT NULL,
    "tokens_used" integer DEFAULT 0 NOT NULL,
    "cost" numeric(10,6) DEFAULT 0,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."usage_records" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."usage_records_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."usage_records_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."usage_records_id_seq" OWNED BY "public"."usage_records"."id";



CREATE TABLE IF NOT EXISTS "public"."user_plans" (
    "id" bigint NOT NULL,
    "user_id" integer NOT NULL,
    "plan_id" bigint NOT NULL,
    "is_active" boolean DEFAULT true,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_plans" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."user_plans_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."user_plans_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."user_plans_id_seq" OWNED BY "public"."user_plans"."id";



CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" bigint NOT NULL,
    "username" character varying(255) NOT NULL,
    "email" character varying(255) NOT NULL,
    "api_key" character varying(255),
    "credits" numeric(10,2) DEFAULT 10.00,
    "is_active" boolean DEFAULT true,
    "registration_date" timestamp with time zone DEFAULT "now"(),
    "auth_method" character varying(50) DEFAULT 'email'::character varying,
    "subscription_status" character varying(50) DEFAULT 'trial'::character varying,
    "trial_expires_at" timestamp with time zone,
    "welcome_email_sent" boolean DEFAULT false,
    "privy_user_id" character varying(255),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."users" OWNER TO "postgres";


COMMENT ON TABLE "public"."users" IS 'User accounts and authentication';



CREATE SEQUENCE IF NOT EXISTS "public"."users_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."users_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."users_id_seq" OWNED BY "public"."users"."id";



ALTER TABLE ONLY "public"."api_keys_new" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."api_keys_new_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."chat_messages" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."chat_messages_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."chat_sessions" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."chat_sessions_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."openrouter_apps" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."openrouter_apps_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."openrouter_models" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."openrouter_models_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."payments" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."payments_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."plans" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."plans_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."pricing_tiers" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."pricing_tiers_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."trial_config" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."trial_config_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."usage_records" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."usage_records_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."user_plans" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."user_plans_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."users" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."users_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."activity_log"
    ADD CONSTRAINT "activity_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."api_keys_new"
    ADD CONSTRAINT "api_keys_new_api_key_key" UNIQUE ("api_key");



ALTER TABLE ONLY "public"."api_keys_new"
    ADD CONSTRAINT "api_keys_new_key_hash_key" UNIQUE ("key_hash");



ALTER TABLE ONLY "public"."api_keys_new"
    ADD CONSTRAINT "api_keys_new_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_messages"
    ADD CONSTRAINT "chat_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_sessions"
    ADD CONSTRAINT "chat_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."credit_transactions"
    ADD CONSTRAINT "credit_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."openrouter_apps"
    ADD CONSTRAINT "openrouter_apps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."openrouter_models"
    ADD CONSTRAINT "openrouter_models_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."plans"
    ADD CONSTRAINT "plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pricing_tiers"
    ADD CONSTRAINT "pricing_tiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pricing_tiers"
    ADD CONSTRAINT "pricing_tiers_tier_name_key" UNIQUE ("tier_name");



ALTER TABLE ONLY "public"."trial_config"
    ADD CONSTRAINT "trial_config_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."openrouter_apps"
    ADD CONSTRAINT "unique_app_period" UNIQUE ("app_name", "time_period");



ALTER TABLE ONLY "public"."openrouter_models"
    ADD CONSTRAINT "unique_model_author_period" UNIQUE ("model_name", "author", "time_period");



ALTER TABLE ONLY "public"."usage_records"
    ADD CONSTRAINT "usage_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_plans"
    ADD CONSTRAINT "user_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_api_key_key" UNIQUE ("api_key");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_privy_user_id_key" UNIQUE ("privy_user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_username_key" UNIQUE ("username");



CREATE INDEX "idx_activity_log_model" ON "public"."activity_log" USING "btree" ("model");



CREATE INDEX "idx_activity_log_provider" ON "public"."activity_log" USING "btree" ("provider");



CREATE INDEX "idx_activity_log_timestamp" ON "public"."activity_log" USING "btree" ("timestamp" DESC);



CREATE INDEX "idx_activity_log_user_id" ON "public"."activity_log" USING "btree" ("user_id");



CREATE INDEX "idx_activity_log_user_timestamp" ON "public"."activity_log" USING "btree" ("user_id", "timestamp" DESC);



CREATE INDEX "idx_api_keys_api_key" ON "public"."api_keys_new" USING "btree" ("api_key");



CREATE INDEX "idx_api_keys_environment" ON "public"."api_keys_new" USING "btree" ("environment_tag");



CREATE INDEX "idx_api_keys_is_active" ON "public"."api_keys_new" USING "btree" ("is_active");



CREATE INDEX "idx_api_keys_key_hash" ON "public"."api_keys_new" USING "btree" ("key_hash");



CREATE INDEX "idx_api_keys_new_key_hash" ON "public"."api_keys_new" USING "btree" ("key_hash");



CREATE INDEX "idx_api_keys_user_id" ON "public"."api_keys_new" USING "btree" ("user_id");



CREATE INDEX "idx_chat_messages_created_at" ON "public"."chat_messages" USING "btree" ("created_at");



CREATE INDEX "idx_chat_messages_role" ON "public"."chat_messages" USING "btree" ("role");



CREATE INDEX "idx_chat_messages_session_created" ON "public"."chat_messages" USING "btree" ("session_id", "created_at");



CREATE INDEX "idx_chat_messages_session_id" ON "public"."chat_messages" USING "btree" ("session_id");



CREATE INDEX "idx_chat_sessions_is_active" ON "public"."chat_sessions" USING "btree" ("is_active");



CREATE INDEX "idx_chat_sessions_updated_at" ON "public"."chat_sessions" USING "btree" ("updated_at" DESC);



CREATE INDEX "idx_chat_sessions_user_active" ON "public"."chat_sessions" USING "btree" ("user_id", "is_active", "updated_at" DESC);



CREATE INDEX "idx_chat_sessions_user_id" ON "public"."chat_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_credit_transactions_created_at" ON "public"."credit_transactions" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_credit_transactions_type" ON "public"."credit_transactions" USING "btree" ("transaction_type");



CREATE INDEX "idx_credit_transactions_user_id" ON "public"."credit_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_openrouter_apps_rank" ON "public"."openrouter_apps" USING "btree" ("rank");



CREATE INDEX "idx_openrouter_apps_scraped_at" ON "public"."openrouter_apps" USING "btree" ("scraped_at");



CREATE INDEX "idx_openrouter_apps_time_period" ON "public"."openrouter_apps" USING "btree" ("time_period");



CREATE INDEX "idx_openrouter_models_rank" ON "public"."openrouter_models" USING "btree" ("rank");



CREATE INDEX "idx_openrouter_models_scraped_at" ON "public"."openrouter_models" USING "btree" ("scraped_at");



CREATE INDEX "idx_openrouter_models_time_period" ON "public"."openrouter_models" USING "btree" ("time_period");



CREATE INDEX "idx_payments_created_at" ON "public"."payments" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_payments_status" ON "public"."payments" USING "btree" ("status");



CREATE INDEX "idx_payments_stripe_intent" ON "public"."payments" USING "btree" ("stripe_payment_intent_id");



CREATE INDEX "idx_payments_stripe_session" ON "public"."payments" USING "btree" ("stripe_checkout_session_id");



CREATE INDEX "idx_payments_user_id" ON "public"."payments" USING "btree" ("user_id");



CREATE INDEX "idx_payments_user_status" ON "public"."payments" USING "btree" ("user_id", "status");



CREATE INDEX "idx_usage_records_api_key" ON "public"."usage_records" USING "btree" ("api_key");



CREATE INDEX "idx_usage_records_created_at" ON "public"."usage_records" USING "btree" ("created_at");



CREATE INDEX "idx_usage_records_timestamp" ON "public"."usage_records" USING "btree" ("timestamp");



CREATE INDEX "idx_usage_records_user_id" ON "public"."usage_records" USING "btree" ("user_id");



CREATE INDEX "idx_user_plans_plan_id" ON "public"."user_plans" USING "btree" ("plan_id");



CREATE INDEX "idx_user_plans_user_id" ON "public"."user_plans" USING "btree" ("user_id");



CREATE INDEX "idx_users_api_key" ON "public"."users" USING "btree" ("api_key");



CREATE INDEX "idx_users_email" ON "public"."users" USING "btree" ("email");



CREATE INDEX "idx_users_privy_user_id" ON "public"."users" USING "btree" ("privy_user_id");



CREATE INDEX "idx_users_subscription_status" ON "public"."users" USING "btree" ("subscription_status");



CREATE OR REPLACE TRIGGER "update_api_keys_updated_at" BEFORE UPDATE ON "public"."api_keys_new" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_payments_updated_at" BEFORE UPDATE ON "public"."payments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_users_updated_at" BEFORE UPDATE ON "public"."users" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."api_keys_new"
    ADD CONSTRAINT "api_keys_new_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_messages"
    ADD CONSTRAINT "fk_chat_messages_session_id" FOREIGN KEY ("session_id") REFERENCES "public"."chat_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_sessions"
    ADD CONSTRAINT "fk_chat_sessions_user_id" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."credit_transactions"
    ADD CONSTRAINT "fk_payment" FOREIGN KEY ("payment_id") REFERENCES "public"."payments"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."credit_transactions"
    ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."activity_log"
    ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."usage_records"
    ADD CONSTRAINT "usage_records_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_plans"
    ADD CONSTRAINT "user_plans_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."plans"("id");



ALTER TABLE ONLY "public"."user_plans"
    ADD CONSTRAINT "user_plans_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Service role can insert activity" ON "public"."activity_log" FOR INSERT WITH CHECK (true);



CREATE POLICY "Service role has full access to api_keys" ON "public"."api_keys_new" USING (true);



CREATE POLICY "Service role has full access to payments" ON "public"."payments" USING (true);



CREATE POLICY "Service role has full access to users" ON "public"."users" USING (true);



CREATE POLICY "Users can view own activity" ON "public"."activity_log" FOR SELECT USING ((("auth"."uid"())::"text" = ("user_id")::"text"));



CREATE POLICY "Users can view their own API keys" ON "public"."api_keys_new" FOR SELECT USING (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE (("users"."privy_user_id")::"text" = ("auth"."uid"())::"text"))));



CREATE POLICY "Users can view their own data" ON "public"."users" FOR SELECT USING ((("auth"."uid"())::"text" = ("privy_user_id")::"text"));



CREATE POLICY "Users can view their own payments" ON "public"."payments" FOR SELECT USING (("user_id" IN ( SELECT "users"."id"
   FROM "public"."users"
  WHERE (("users"."privy_user_id")::"text" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."activity_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "anon_can_insert" ON "public"."credit_transactions" FOR INSERT TO "anon" WITH CHECK (true);



ALTER TABLE "public"."api_keys_new" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."chat_messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."chat_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."credit_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."openrouter_apps" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."openrouter_models" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pricing_tiers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "service_role_all" ON "public"."credit_transactions" TO "service_role" USING (true) WITH CHECK (true);



ALTER TABLE "public"."trial_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."usage_records" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "users_can_view_own_transactions" ON "public"."credit_transactions" FOR SELECT TO "authenticated" USING (("user_id" = ((("current_setting"('request.jwt.claims'::"text", true))::json ->> 'user_id'::"text"))::integer));





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";


















GRANT ALL ON TABLE "public"."activity_log" TO "anon";
GRANT ALL ON TABLE "public"."activity_log" TO "authenticated";
GRANT ALL ON TABLE "public"."activity_log" TO "service_role";



GRANT ALL ON SEQUENCE "public"."activity_log_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."activity_log_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."activity_log_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."api_keys_new" TO "anon";
GRANT ALL ON TABLE "public"."api_keys_new" TO "authenticated";
GRANT ALL ON TABLE "public"."api_keys_new" TO "service_role";



GRANT ALL ON SEQUENCE "public"."api_keys_new_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."api_keys_new_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."api_keys_new_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."chat_messages" TO "anon";
GRANT ALL ON TABLE "public"."chat_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_messages" TO "service_role";



GRANT ALL ON SEQUENCE "public"."chat_messages_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."chat_messages_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."chat_messages_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."chat_sessions" TO "anon";
GRANT ALL ON TABLE "public"."chat_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_sessions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."chat_sessions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."chat_sessions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."chat_sessions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."credit_transactions" TO "anon";
GRANT ALL ON TABLE "public"."credit_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."credit_transactions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."credit_transactions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."credit_transactions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."credit_transactions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."openrouter_apps" TO "anon";
GRANT ALL ON TABLE "public"."openrouter_apps" TO "authenticated";
GRANT ALL ON TABLE "public"."openrouter_apps" TO "service_role";



GRANT ALL ON TABLE "public"."latest_apps" TO "anon";
GRANT ALL ON TABLE "public"."latest_apps" TO "authenticated";
GRANT ALL ON TABLE "public"."latest_apps" TO "service_role";



GRANT ALL ON TABLE "public"."openrouter_models" TO "anon";
GRANT ALL ON TABLE "public"."openrouter_models" TO "authenticated";
GRANT ALL ON TABLE "public"."openrouter_models" TO "service_role";



GRANT ALL ON TABLE "public"."latest_models" TO "anon";
GRANT ALL ON TABLE "public"."latest_models" TO "authenticated";
GRANT ALL ON TABLE "public"."latest_models" TO "service_role";



GRANT ALL ON SEQUENCE "public"."openrouter_apps_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."openrouter_apps_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."openrouter_apps_id_seq" TO "service_role";



GRANT ALL ON SEQUENCE "public"."openrouter_models_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."openrouter_models_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."openrouter_models_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."payments" TO "anon";
GRANT ALL ON TABLE "public"."payments" TO "authenticated";
GRANT ALL ON TABLE "public"."payments" TO "service_role";



GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."plans" TO "anon";
GRANT ALL ON TABLE "public"."plans" TO "authenticated";
GRANT ALL ON TABLE "public"."plans" TO "service_role";



GRANT ALL ON SEQUENCE "public"."plans_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."plans_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."plans_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."pricing_tiers" TO "anon";
GRANT ALL ON TABLE "public"."pricing_tiers" TO "authenticated";
GRANT ALL ON TABLE "public"."pricing_tiers" TO "service_role";



GRANT ALL ON SEQUENCE "public"."pricing_tiers_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."pricing_tiers_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."pricing_tiers_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."trial_config" TO "anon";
GRANT ALL ON TABLE "public"."trial_config" TO "authenticated";
GRANT ALL ON TABLE "public"."trial_config" TO "service_role";



GRANT ALL ON SEQUENCE "public"."trial_config_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."trial_config_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."trial_config_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."usage_records" TO "anon";
GRANT ALL ON TABLE "public"."usage_records" TO "authenticated";
GRANT ALL ON TABLE "public"."usage_records" TO "service_role";



GRANT ALL ON SEQUENCE "public"."usage_records_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."usage_records_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."usage_records_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_plans" TO "anon";
GRANT ALL ON TABLE "public"."user_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."user_plans" TO "service_role";



GRANT ALL ON SEQUENCE "public"."user_plans_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_plans_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_plans_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."users_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































RESET ALL;

