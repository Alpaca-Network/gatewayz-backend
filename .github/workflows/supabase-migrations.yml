name: Supabase Migrations

on:
  push:
    branches: [main]
    paths:
      - "supabase/migrations/*.sql"
  schedule:
    # Drift check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run — validate only, don't apply"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: supabase-migrations
  cancel-in-progress: false

jobs:
  validate:
    name: Validate Migrations
    runs-on: ubuntu-latest
    # Only validate when migration files are pushed (not on schedule/dispatch)
    if: github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Check migration file naming
        run: |
          shopt -s nullglob
          files=(supabase/migrations/*.sql)
          shopt -u nullglob

          if [ ${#files[@]} -eq 0 ]; then
            echo "No migration files found"
            exit 0
          fi

          for file in "${files[@]}"; do
            filename=$(basename "$file")
            if ! [[ "$filename" =~ ^[0-9]{14}_[a-z0-9_]+\.sql$ ]]; then
              echo "::error::Invalid migration filename: $filename (expected YYYYMMDDHHMMSS_description.sql)"
              exit 1
            fi
          done
          echo "All migration filenames are valid"

      - name: Check for destructive operations
        run: |
          for file in supabase/migrations/*.sql; do
            [ -f "$file" ] || continue
            if grep -iE "DROP DATABASE|DROP SCHEMA public|TRUNCATE.*CASCADE" "$file"; then
              echo "::error::Destructive operation found in $file — review manually before applying"
              exit 1
            fi
          done
          echo "No destructive operations detected"

  sync:
    name: Sync Migrations
    runs-on: ubuntu-latest
    needs: validate
    # Run after validate on push, or always on schedule/dispatch
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    environment: production

    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}" \
                        --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Check for drift
        id: drift
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Capture migration list output
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          # Check for remote-only migrations (applied on DB but missing locally)
          if grep -q "remote only" migration-status.txt; then
            echo "drift=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Schema drift detected — remote DB has migrations not in the repo"
          else
            echo "drift=false" >> "$GITHUB_OUTPUT"
            echo "No drift detected"
          fi

      - name: Pull remote migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase db pull --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
          echo "Pulled remote-only migrations into supabase/migrations/"

      - name: Open PR for pulled migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="fix/schema-drift-$(date +%Y%m%d%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH"
          git add supabase/migrations/
          git commit -m "fix: pull schema drift from remote database"
          git push origin "$BRANCH"

          gh pr create \
            --title "fix: sync schema drift from remote database" \
            --body "$(cat <<'EOF'
          ## Schema Drift Detected

          The remote database has migrations that are not in this repo.
          This PR pulls those changes so the repo stays in sync.

          **Review the SQL carefully before merging.**

          Detected by the scheduled drift check workflow.
          EOF
          )" \
            --base main \
            --head "$BRANCH"

      - name: Repair already-applied migrations
        if: steps.drift.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Parse migration list to find migrations that exist locally but failed
          # to track in schema_migrations (e.g. applied manually or via a partial run).
          # These show up as pending in "db push" but already have their version key
          # in the DB, causing a duplicate key error.
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          # Look for lines with a timestamp and no "applied" or "remote only" marker —
          # but we can't reliably distinguish from the list alone. Instead, attempt a
          # dry push and repair any version that hits a duplicate key conflict.
          supabase db push --password "${{ secrets.SUPABASE_DB_PASSWORD }}" --include-all 2>&1 | tee push-dry.txt || true

          # Extract versions that failed with duplicate key
          DUPES=$(grep -oP 'Key \(version\)=\(\K[0-9]+' push-dry.txt || true)

          if [ -n "$DUPES" ]; then
            echo "Found already-applied migrations that need repair: $DUPES"
            for ver in $DUPES; do
              echo "Repairing migration $ver → marking as applied"
              supabase migration repair --status applied "$ver" --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
            done
            echo "Repair complete — will retry push"
          else
            echo "No duplicate migrations to repair"
            # Check if the first push actually succeeded
            if grep -q "Migrations applied successfully\|No migrations to push" push-dry.txt 2>/dev/null; then
              echo "push_succeeded=true" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Push local migrations to remote
        id: push
        if: steps.drift.outputs.drift == 'false' && github.event.inputs.dry_run != 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase db push --password "${{ secrets.SUPABASE_DB_PASSWORD }}" --include-all 2>&1 | tee migration-output.txt
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "::error::Migration failed — see logs above"
            exit 1
          fi
          echo "Migrations applied successfully"

      - name: Verify migration status
        if: steps.drift.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-logs
          path: |
            migration-status.txt
            migration-output.txt
          if-no-files-found: ignore
