name: Supabase Migrations

on:
  push:
    branches: [main]
    paths:
      - "supabase/migrations/*.sql"
  schedule:
    # Drift check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run — validate only, don't apply"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: supabase-migrations
  cancel-in-progress: false

jobs:
  validate:
    name: Validate Migrations
    runs-on: ubuntu-latest
    # Only validate when migration files are pushed (not on schedule/dispatch)
    if: github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Check migration file naming
        run: |
          shopt -s nullglob
          files=(supabase/migrations/*.sql)
          shopt -u nullglob

          if [ ${#files[@]} -eq 0 ]; then
            echo "No migration files found"
            exit 0
          fi

          for file in "${files[@]}"; do
            filename=$(basename "$file")
            if ! [[ "$filename" =~ ^[0-9]{14}_[a-z0-9_]+\.sql$ ]]; then
              echo "::error::Invalid migration filename: $filename (expected YYYYMMDDHHMMSS_description.sql)"
              exit 1
            fi
          done
          echo "All migration filenames are valid"

      - name: Check for destructive operations
        run: |
          for file in supabase/migrations/*.sql; do
            [ -f "$file" ] || continue
            if grep -iE "DROP DATABASE|DROP SCHEMA public|TRUNCATE.*CASCADE" "$file"; then
              echo "::error::Destructive operation found in $file — review manually before applying"
              exit 1
            fi
          done
          echo "No destructive operations detected"

  sync:
    name: Sync Migrations
    runs-on: ubuntu-latest
    needs: validate
    # Run after validate on push, or always on schedule/dispatch
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    environment: production

    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}" \
                        --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Check for drift
        id: drift
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Capture migration list output
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          # Check for remote-only migrations (applied on DB but missing locally)
          if grep -q "remote only" migration-status.txt; then
            echo "drift=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Schema drift detected — remote DB has migrations not in the repo"
          else
            echo "drift=false" >> "$GITHUB_OUTPUT"
            echo "No drift detected"
          fi

      - name: Pull remote migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase db pull --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
          echo "Pulled remote-only migrations into supabase/migrations/"

      - name: Open PR for pulled migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="fix/schema-drift-$(date +%Y%m%d%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH"
          git add supabase/migrations/
          git commit -m "fix: pull schema drift from remote database"
          git push origin "$BRANCH"

          gh pr create \
            --title "fix: sync schema drift from remote database" \
            --body "$(cat <<'EOF'
          ## Schema Drift Detected

          The remote database has migrations that are not in this repo.
          This PR pulls those changes so the repo stays in sync.

          **Review the SQL carefully before merging.**

          Detected by the scheduled drift check workflow.
          EOF
          )" \
            --base main \
            --head "$BRANCH"

      - name: Push local migrations to remote
        id: push
        if: steps.drift.outputs.drift == 'false' && github.event.inputs.dry_run != 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          MAX_RETRIES=3
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_RETRIES ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Push attempt $ATTEMPT/$MAX_RETRIES..."

            yes | supabase db push --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-output.txt
            EXIT_CODE=${PIPESTATUS[1]}

            if [ $EXIT_CODE -eq 0 ]; then
              echo "Migrations applied successfully"
              exit 0
            fi

            # Check if failure is due to duplicate key (already-applied migration)
            DUPES=$(grep -oP 'Key \(version\)=\(\K[0-9]+' migration-output.txt || true)

            if [ -z "$DUPES" ]; then
              echo "::error::Migration failed with non-duplicate error — see logs above"
              exit 1
            fi

            # Repair each duplicate version and retry
            for ver in $DUPES; do
              echo "Migration $ver already exists in schema_migrations — repairing"
              supabase migration repair --status applied "$ver" --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
            done

            echo "Repaired — retrying push..."
          done

          echo "::error::Migration failed after $MAX_RETRIES attempts"
          exit 1

      - name: Verify migration status
        if: steps.drift.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-logs
          path: |
            migration-status.txt
            migration-output.txt
          if-no-files-found: ignore
