name: Supabase Migrations

on:
  push:
    branches: [main]
    paths:
      - "supabase/migrations/*.sql"
  schedule:
    # Drift check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run — validate only, don't apply"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: supabase-migrations
  cancel-in-progress: false

jobs:
  validate:
    name: Validate Migrations
    runs-on: ubuntu-latest
    # Only validate when migration files are pushed (not on schedule/dispatch)
    if: github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Check migration file naming
        run: |
          shopt -s nullglob
          files=(supabase/migrations/*.sql)
          shopt -u nullglob

          if [ ${#files[@]} -eq 0 ]; then
            echo "No migration files found"
            exit 0
          fi

          for file in "${files[@]}"; do
            filename=$(basename "$file")
            if ! [[ "$filename" =~ ^[0-9]{14}_[a-z0-9_]+\.sql$ ]]; then
              echo "::error::Invalid migration filename: $filename (expected YYYYMMDDHHMMSS_description.sql)"
              exit 1
            fi
          done
          echo "All migration filenames are valid"

      - name: Check for destructive operations
        run: |
          for file in supabase/migrations/*.sql; do
            [ -f "$file" ] || continue
            if grep -iE "DROP DATABASE|DROP SCHEMA public|TRUNCATE.*CASCADE" "$file"; then
              echo "::error::Destructive operation found in $file — review manually before applying"
              exit 1
            fi
          done
          echo "No destructive operations detected"

  sync:
    name: Sync Migrations
    runs-on: ubuntu-latest
    needs: validate
    # Run after validate on push, or always on schedule/dispatch
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    environment: production

    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}" \
                        --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Check migration status
        id: status
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          # Detect drift: lines where REMOTE has a version but LOCAL is empty
          # Format: "   LOCAL          | REMOTE         | TIME"
          DRIFT=$(awk -F'|' '{
            gsub(/[ \t]/, "", $1); gsub(/[ \t]/, "", $2);
            if ($2 ~ /^[0-9]{14}$/ && $1 !~ /^[0-9]{14}$/) print $2
          }' migration-status.txt || true)

          if [ -n "$DRIFT" ]; then
            echo "drift=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Schema drift detected — remote has migrations not in local repo:"
            echo "$DRIFT"
          else
            echo "drift=false" >> "$GITHUB_OUTPUT"
            echo "No drift detected"
          fi

          # Check for pending local-only migrations
          PENDING=$(awk -F'|' '{
            gsub(/[ \t]/, "", $1); gsub(/[ \t]/, "", $2);
            if ($1 ~ /^[0-9]{14}$/ && $2 !~ /^[0-9]{14}$/) print $1
          }' migration-status.txt || true)

          if [ -n "$PENDING" ]; then
            echo "pending=true" >> "$GITHUB_OUTPUT"
            echo "Pending migrations to push:"
            echo "$PENDING"
          else
            echo "pending=false" >> "$GITHUB_OUTPUT"
            echo "No pending migrations"
          fi

      - name: Pull remote migrations
        if: steps.status.outputs.drift == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase db pull --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
          echo "Pulled remote-only migrations into supabase/migrations/"

      - name: Open PR for pulled migrations
        if: steps.status.outputs.drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="fix/schema-drift-$(date +%Y%m%d%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH"
          git add supabase/migrations/
          git commit -m "fix: pull schema drift from remote database"
          git push origin "$BRANCH"

          gh pr create \
            --title "fix: sync schema drift from remote database" \
            --body "$(cat <<'EOF'
          ## Schema Drift Detected

          The remote database has migrations that are not in this repo.
          This PR pulls those changes so the repo stays in sync.

          **Review the SQL carefully before merging.**

          Detected by the scheduled drift check workflow.
          EOF
          )" \
            --base main \
            --head "$BRANCH"

      - name: Push migrations to remote
        if: |
          steps.status.outputs.drift == 'false' &&
          steps.status.outputs.pending == 'true' &&
          github.event.inputs.dry_run != 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # --include-all skips the interactive confirmation prompt in CI.
          # db push automatically skips already-applied migrations and only
          # applies new ones — all local files must be present for this to work.
          supabase db push --include-all --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-output.txt
          echo "Migrations applied successfully"

      - name: Verify migration status
        if: steps.status.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-logs
          path: |
            migration-status.txt
            migration-output.txt
          if-no-files-found: ignore
