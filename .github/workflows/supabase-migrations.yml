name: Supabase Migrations

on:
  push:
    branches: [main]
    paths:
      - "supabase/migrations/*.sql"
  schedule:
    # Drift check every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Dry run — validate only, don't apply"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: supabase-migrations
  cancel-in-progress: false

jobs:
  validate:
    name: Validate Migrations
    runs-on: ubuntu-latest
    # Only validate when migration files are pushed (not on schedule/dispatch)
    if: github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4

      - name: Check migration file naming
        run: |
          shopt -s nullglob
          files=(supabase/migrations/*.sql)
          shopt -u nullglob

          if [ ${#files[@]} -eq 0 ]; then
            echo "No migration files found"
            exit 0
          fi

          for file in "${files[@]}"; do
            filename=$(basename "$file")
            if ! [[ "$filename" =~ ^[0-9]{14}_[a-z0-9_]+\.sql$ ]]; then
              echo "::error::Invalid migration filename: $filename (expected YYYYMMDDHHMMSS_description.sql)"
              exit 1
            fi
          done
          echo "All migration filenames are valid"

      - name: Check for destructive operations
        run: |
          for file in supabase/migrations/*.sql; do
            [ -f "$file" ] || continue
            if grep -iE "DROP DATABASE|DROP SCHEMA public|TRUNCATE.*CASCADE" "$file"; then
              echo "::error::Destructive operation found in $file — review manually before applying"
              exit 1
            fi
          done
          echo "No destructive operations detected"

  sync:
    name: Sync Migrations
    runs-on: ubuntu-latest
    needs: validate
    # Run after validate on push, or always on schedule/dispatch
    if: |
      always() &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    environment: production

    steps:
      - uses: actions/checkout@v4

      - uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link Supabase project
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}" \
                        --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Check for drift
        id: drift
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Capture migration list output
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          # Check for remote-only migrations (applied on DB but missing locally)
          if grep -q "remote only" migration-status.txt; then
            echo "drift=true" >> "$GITHUB_OUTPUT"
            echo "::warning::Schema drift detected — remote DB has migrations not in the repo"
          else
            echo "drift=false" >> "$GITHUB_OUTPUT"
            echo "No drift detected"
          fi

      - name: Pull remote migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          supabase db pull --password "${{ secrets.SUPABASE_DB_PASSWORD }}"
          echo "Pulled remote-only migrations into supabase/migrations/"

      - name: Open PR for pulled migrations
        if: steps.drift.outputs.drift == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="fix/schema-drift-$(date +%Y%m%d%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH"
          git add supabase/migrations/
          git commit -m "fix: pull schema drift from remote database"
          git push origin "$BRANCH"

          gh pr create \
            --title "fix: sync schema drift from remote database" \
            --body "$(cat <<'EOF'
          ## Schema Drift Detected

          The remote database has migrations that are not in this repo.
          This PR pulls those changes so the repo stays in sync.

          **Review the SQL carefully before merging.**

          Detected by the scheduled drift check workflow.
          EOF
          )" \
            --base main \
            --head "$BRANCH"

      - name: Reconcile already-applied migrations
        if: steps.drift.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # migration list output format:
          #   LOCAL          │ REMOTE         │ TIME (UTC)
          #   ───────────────┼────────────────┼──────────────
          #   20260212000000 │ 20260212000000 │ 2024-...       ← applied (both columns)
          #   20260217000000 │                │                 ← local only (pending)
          supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-status.txt

          echo "=== Migration list output ==="
          cat migration-status.txt
          echo "=== End migration list ==="

          # Extract REMOTE column versions (versions that have been applied to the DB).
          # Format: "   LOCAL          | REMOTE         | TIME"
          # A line where REMOTE has a 14-digit number means that version is applied.
          # We extract the second column (after the first |, before the second |).
          REMOTE_VERSIONS=$(awk -F'|' '{gsub(/[^0-9]/, "", $2); if ($2 ~ /^[0-9]{14}$/) print $2}' migration-status.txt || true)

          if [ -z "$REMOTE_VERSIONS" ]; then
            echo "No previously applied migrations found — all will be pushed"
            exit 0
          fi

          echo "Remote has $(echo "$REMOTE_VERSIONS" | wc -l | tr -d ' ') applied migrations"

          # Temporarily move local migration files whose version is already on remote.
          # Match by exact filename prefix to handle duplicate timestamps correctly.
          mkdir -p /tmp/applied-migrations
          for ver in $REMOTE_VERSIONS; do
            for FILE in supabase/migrations/${ver}_*.sql; do
              [ -f "$FILE" ] || continue
              BASENAME=$(basename "$FILE")
              # Only move if this exact file's version matches a remote version.
              # For duplicate timestamps (e.g. two files with 20260212000000),
              # we need to check which one is actually tracked on remote.
              # The remote tracks by version number, so ALL local files with
              # that version would conflict. Move them all — the new one with
              # the duplicate timestamp needs to be renamed anyway.
              echo "Skipping already-applied migration: $BASENAME"
              mv "$FILE" /tmp/applied-migrations/
            done
          done

          echo "Remaining migrations to push:"
          ls supabase/migrations/*.sql 2>/dev/null || echo "  (none)"

      - name: Push local migrations to remote
        id: push
        if: steps.drift.outputs.drift == 'false' && github.event.inputs.dry_run != 'true'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          # Check if there are any pending migrations left to push
          PENDING=$(ls supabase/migrations/*.sql 2>/dev/null | wc -l)
          if [ "$PENDING" -eq 0 ]; then
            echo "No new migrations to push"
            exit 0
          fi

          yes | supabase db push --password "${{ secrets.SUPABASE_DB_PASSWORD }}" 2>&1 | tee migration-output.txt
          EXIT_CODE=${PIPESTATUS[1]}

          # Restore moved files regardless of outcome
          if [ -d /tmp/applied-migrations ] && ls /tmp/applied-migrations/*.sql &>/dev/null; then
            mv /tmp/applied-migrations/*.sql supabase/migrations/
          fi

          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::Migration failed — see logs above"
            exit 1
          fi
          echo "Migrations applied successfully"

      - name: Restore migration files
        if: always()
        run: |
          # Ensure applied migration files are restored even if push failed
          if [ -d /tmp/applied-migrations ] && ls /tmp/applied-migrations/*.sql &>/dev/null; then
            mv /tmp/applied-migrations/*.sql supabase/migrations/
          fi

      - name: Verify migration status
        if: steps.drift.outputs.drift == 'false'
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: supabase migration list --password "${{ secrets.SUPABASE_DB_PASSWORD }}"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migration-logs
          path: |
            migration-status.txt
            migration-output.txt
          if-no-files-found: ignore
